() => {
  // 6 kyu
  // Big Counting
  //
  // Напишите функцию, которая принимает число на вход и возращает кол-во битов, равное
  // Единице в двоичном представлении этого числа. Вы знаете, что входные данные не отриц.
  //
  // Пример:
  // Двоичное представление 1234 = 10011010010, поэтому функция должна вернуть 5

  function countBits(num) {
    return num
      .toString(2)
      .split("")
      .filter((item) => item === "1").length;
  }
  countBits(1234);
};

() => {
  // 6 kyu
  // Basics 08: Find next higher number with same Bits (1's)
  //
  // Ваша задача - найти следующее большее число с таким же кол-вом битов '1'.
  //
  // Т.е. столько же битов '1', сколько и раньше, и вывести следующее число, которое будет
  // больше, чем входное. Входные данные всегда имеют значение от 1 до 30 (включительно).
  // Никаких сложных случаев или спец. приемов.
  //
  // Несколько простых примеров:
  //
  //   Ввод: 129 => Вывод: 130 (10000001 => 10000010)
  // Ввод: 127 => Вывод: 191 (011111111 => 101111111)
  // Ввод: 1 => Вывод: 2 (01 => 10)
  // Вход: 323423 => Выход: 323439 (1001110111101011111 => 1001110111101101111)
  // Сначала несколько статических тестов, а затем и множество случайных;-)!
  // Надеюсь, вам будет весело! :-)

  const toBits = (int) => {
    return int
      .toString(2)
      .split("")
      .filter((item) => item === "1").length;
  };

  function nextHigher(n) {
    const currentBits = toBits(n);
    // let res = 0;
    let next = toBits(n + 1);
    // for (let i = n + 1; currentBits !== next; i++) {
    //   console.log(i);
    //   next = toBits(i);
    //   res = i;
    // }
    console.log(currentBits, next);
    let i = n + 1;
    if (currentBits === next) {
      return n + 1;
    }
    while (currentBits !== next) {
      next = toBits(i);
      i++;
    }
    return i - 1;
  }
  nextHigher(1);
};
