// Рекурсия - прием в программировании, когда функция вызывает саму себя.
// Прием полезен в случаях, когда задача может быть естественно разделена несколько
// Аналогичных, но более простых задач. Или когда задача может быть упрощена до
// Несложных действий плюс простой вариант этой задачи.

// pow(2, 2) = 4
// pow(2, 3) = 8
// pow(2, 4) = 16

() => {
  // Цикл
  function pow(x, n) {
    let res = x;
    for (let i = 1; i < n; i++) {
      res *= x;
    }
    return res;
  }
  pow(2, 4);
};

() => {
  // Рекурсия
  function pow(x, n) {
    if (n < 2) {
      return x;
    }
    return x * pow(x, n - 1);
  }

  // 2, 4 => 2 * pow(2, 4 - 1)
  // 2, 3 => 2 * pow(2, 3 - 1)
  // 2, 2 => 2 * pow(2, 2 - 1)
  // 2, 1 => 2
  // 2 * 2 = 4
  // 2 * 4 = 8
  // 2 * 8 = 16

  pow(2, 4);
};

// Контекст выполнения, стэк
// Информация о процессе выполнения запущенной функции хранится в ее контексте
// выполнения (execution context).
// Контекст выполнения - специальная внутреняя структура данных, которая содержит
// информацию о вызове функции. Она включает в себя конкретное место в коде, на
// котором находится интерпретатор, локальные переменные функции, this и пр. служ. инф.

// Один вызов функции имеет ровно один конекст исполнения.

// Когда функция производит вложенный вызов, происходит следующее:
// - Выполнение текущей функции приостаналивается.
// - Конекст выполнения, связанный с ней, запоминается в специально структуре данных -
//   стеке контекстов выполнения.
// - Выполняются вложенный вызовы, для каждого из которых создается свой конекст выполнения
// - После их завершения старый контекст достается из стека, и выполнение внешней
//   функции возобновляется с того места, где она была остановлена.

// Рекурсивные обходы
// Другим отличным применением рекурсии является рекурсивный обход.

() => {
  let company = {
    sales: [
      { name: "John", salary: 1000 },
      { name: "Alice", salary: 600 },
    ],
    development: {
      sites: [
        { name: "Peter", salary: 2000 },
        { name: "Alex", salary: 1800 },
      ],
      internals: [{ name: "Jack", salary: 1300 }],
    },
  };

  // Функция для подсчёта суммы зарплат
  function sumSalaries(department) {
    if (Array.isArray(department)) {
      // случай (1)
      return department.reduce((prev, current) => prev + current.salary, 0); // сумма элементов массива
    } else {
      // случай (2)
      let sum = 0;
      for (let subdep of Object.values(department)) {
        sum += sumSalaries(subdep); // рекурсивно вызывается для подотделов, суммируя результаты
      }
      return sum;
    }
  }

  alert(sumSalaries(company)); // 6700
};

// Связанный список
// Если мы хотим хранить упорядоченный список объектов
// Естественным выбором будет массив:

() => {
  let arr = [obj1, obj2, obj3];
};

// Но у массивов есть недостатки. Операции удалить или вставить элемент являются
// дорогостоящими. Например если мы хотим вставить элемент в начало (arr.unshift(obj))
// Такая операция должна переиндексировать все элементы, чтобы освободить место для
// нового obj, и, если массив большой то на это потребуется время. То же самое, если
// arr.shift()

// Единственные структурные изменений, не требующие массовой переиндексации - это
// изменения, которые выполняются с конца массив: arr.push или arr.pop. Таким образом
// массив может быть довольно медленным для больших очередей, когда нам нужно работать
// с его началом.

// Или же, если нам действительно нужны быстрая вставка/удаление, мы можем использовать
// структуру, называемую связанный список.

// Элемент связанного списка определяется рекурсивно, как объект с :
// - value,
// - next - свойство, ссылающееся на след. элемент связанного списка или null,
//   если это последний элемент
// Пример:

() => {
  let list = {
    value: 1,
    next: {
      value: 2,
      next: {
        value: 3,
        next: {
          value: 4,
          next: null,
        },
      },
    },
  };
  // Или альтернативный код для создания:
  () => {
    let list = { value: 1 };
    list.next = { value: 2 };
    list.next.next = { value: 3 };
    list.next.next.next = { value: 4 };
    list.next.next.next.next = null;
  };
};

() => {
  let count = 0;

  function recurse() {
    if (count === 5) {
      return count;
    }
    console.log(count);
    count++;
    return recurse();
  }

  recurse();
};
//////////// DOKA ///////////////
// В программировании под рекурсией чаще всего понимают функцию, которая вызывает саму себя
// При решении некоторых задач мы можем обнаружить, что решение можно разбить на
// несколько простых действий и более простой вариант той же задачи.
//
// Например, при возведении числа в степень мы берем число, умножаем его на себя
// несколько раз. Эту операцию можно представить в виде:

// 2^5 = 2 * 2 * 2 * 2 * 2
//
// 1 шаг: 2
// 2 шаг: 2 * 2
// 3 шаг: 2 * 2 * 2
// 4 шаг: 2 * 2 * 2 * 2
// 5 шаг: 2 * 2 * 2 * 2 * 2
//
// Какой по счёту шаг —
// столько и умножений.
//
//
//
//
// Но это же можно представить в виде нескольких последовательных умножений на 2:

// 2^5 = ((((2 * 2) * 2) * 2) * 2)
//
// 1 шаг: 2
// 2 шаг: 2 * 2  (результат 1-го шага * 2)
// 3 шаг: 4 * 2  (результат 2-го шага * 2)
// 4 шаг: 8 * 2  (результат 3-го шага * 2)
// 5 шаг: 16 * 2  (результат 4-го шага * 2)
//
// Для получения нового результата
// мы берём предыдущий и умножаем его на 2.

() => {
  function pow(x, n) {
    if (n === 1) {
      return x;
    }

    return x * pow(x, n - 1);
  }

  const result = pow(5, 3);
  console.log(result);
};

() => {
  function factorial(n) {
    if (n === 1) {
      return 1;
    }
    return n * factorial(n - 1);
  }
  factorial(5);
};
