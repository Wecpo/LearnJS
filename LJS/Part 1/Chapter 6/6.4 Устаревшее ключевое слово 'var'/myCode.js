// let и const ведут себя одинаково по отношению к лексическому окружению, области видимости.
// Но var - это совершенно другой зверь, берущий свое начало с давних времен. Обычно var
// не используется в современных скриптах, но все еще может скрываться в старых.

// На первый взгляд поведение var похоже на let. Например, объявление переменной:
() => {
  function sayHi() {
    var phrase = "Привет";
    console.log(phrase); // Привет
  }

  sayHi();

  console.log(phrase); // Ошибка // Uncaught
  //   ReferenceError: phrase is not defined
};

// Для var не существует блочной области видимости.
// Область видимости переменных var ограничивается либо функцией, либо, если переменная
// глобальная, то скриптом. Такие переменные доступны за пределами блока.

// Например:

() => {
  if (true) {
    var test = true;
  }

  console.log(test); // true  --- Переменная существует вне блока if
};

// Так как var игнорирует блоки, мы получили глобальную переменную test.
// А если бы мы использовали let test вместо var test, тогда переменная была бы видна только
// Внутри if

() => {
  if (true) {
    let test = true;
  }

  console.log(test); // Reference Error: test is not defined
};

// Аналогично для циклов: var не может быть блочной или локальной внутри цикла:
() => {
  for (var i = 0; i < 10; i++) {
    ///
  }
  console.log(i); // 10
};

() => {
  for (let i = 0; i < 10; i++) {
    //
  }
  console.log(i); // Reference error: i is not defined
};

// Если блок кода находится внутри функции, то var становится локальной переменной
// в этой функции:

() => {
  function sayHi() {
    if (true) {
      var phrase = "Привет";
    }

    console.log(phrase); // Привет
  }

  sayHi();
  console.log(phrase); // Reference Error: phrase is not defined

  // Как мы видим, var выходит за пределы блоков if, for и подобных.
  // Это происходит потому, что на заре JS блоки кода не имели лексического окружения.
  // Поэтому можно сказать, что var - пережиток прошлого.
};

// var допускает повторное объявление
// Если в блоке кода дважды объявить одну и ту же переменную let, будет ошибка:
() => {
  let user;
  // let user // // SyntaxError: 'user' has already been declared
};

// Используя var, можно переобъявлять переменную сколько угодно раз. Повторные var игнорируются:
() => {
  var user = "Петр";
  var user;
  console.log(user); // Петр
};

// Если дополнительно присвоить значение, то переменная примет новое значение:
() => {
  var user = "Петр";
  var user = "Иван";
  console.log(user); // Иван
};

// var обрабатываются в начале запуска функции

// Объявления переменных var обрабатываются в начале выполнения функции (или запуска скрипта,
// если переменная является глобальной)

// Другими словами, переменные var считаются объявленными с самого начала исполнения функции
// вне зависимости от того, в каком месте функции реально находятся их объявления (при условии
// что они не находятся во вложенной функции).

// Т.е. :
() => {
  function sayHi() {
    phrase = "Привет";

    console.log(phrase);

    var phrase;
  }

  sayHi();
};

// Тоже самое :
() => {
  function sayHi() {
    var phrase;
    phrase = "Привет";
    console.log(phrase);
  }

  sayHi();
};

// И даже тут:
() => {
  function sayHi() {
    phrase = "Привет";
    if (false) {
      var phrase; // Не смотря на то, что это условие никогда не выполнится, т.к.
      // блочная облаcть видимости с var игнорируется
    }
    console.log(phrase);
  }
  sayHi();
};

() => {
  function sayHi() {
    phrase = "Привет";
    function v() {
      var phrase1 = "yo";
    }
    v();
    console.log(phrase1); //phrase1 if not defined
  }
  sayHi();
};

// Это поведение называется 'hoisting' (всплытие, поднятие), потому что все объявления
// переменных var 'всплывают' в самый верх функции.
//
// В примере выше if (false) условие никогда не выполнится. Но это не препятствует
// созданию переменой var phrase, которая находится внутри него, поскольку объявления
// var всплывают в начало функции. Т.е. в момент присвоения переменная уже существует.

// Объявления переменных всплывают, но присваивание значений - нет.

// Например:
() => {
  function sayHi() {
    console.log(phrase);
    var phrase = "Привет";
  }
  sayHi();
};

// Строка var phrase = 'Привет' состоит из двух действий:
// 1. Объявление переменной var
// 2. Присвоение значения в переменную =

// Объявление переменной обрабатывается в началае выполнения функции (всплывает) однако
// присвоение значения всегда происходит в той строке кода где оно указано. Т.Е. выполняется
// по следующему сценарию:

() => {
  function sayHi() {
    var phrase; // Объявление переменной происходит в начале
    console.log(phrase); // undefined
    phrase = "Привет"; // присвоение, var = 'Привет'
  }
};

// Поскольку все объявления переменных var обрабатываются в начале функции, мы можем ссылаться
// на них в любом месте. Однако переменные имеют значения undefined до строки с присвоением.

// В обоих примерах выше console.log происходил без ошибки, потому что переменная phrase
// уже существовала. Но ее значение еще не было присвоего, поэтому мы получали Undefined

//
// IIFE
//
// В прошлом, поскольку существовал только var, а он не имел блочной области видимости
// программисты придумали способ ее эмулировать. Этот способ получил название
// 'Immediately-invoked function expressions' (IIFE).
//
// IIFE выглядит следующим образом:

() => {
  (function () {
    var message = "Привет";

    console.log(message);
  })();
};

// Здесь создается и немедленно вызывается Function Expression. Так что код выполняется
// сразу же и у него есть свои локальные переменные.

// Function Expression обернуто в скобки потому, что когда JS встречает 'function' в
// основном потоке кода, он воспринимает это как начало Function Declaration.
// Но у Function Declaration должно быть имя, так что такой код вызовет ошибку:
() => {
  // Пробуем объявить и сразу же вызвать функцию
  // function() { // <-- SyntaxError: Function statements require a function name
  //     var message = "Привет";
  //     alert(message); // Привет
  //   }();
};

// Даже если мы скажем: 'Хорошо, давайте добавим имя' - это не сработает, потому что JS
// Не позволяет вызывать function Declaration немедленно.

// () => {
// ошибка синтаксиса из-за скобок ниже
function go() {
  // }(); // <-- нельзя вызывать Function Declaration немедленно
}

// Так что скобки вокруг функции - это трюк, который позволяет объяснить JS, что функция
// была создана в контексте другого выражения, а значит, что это Function Expression:
// ей не нужно имя и ее можно вызывать немедленно.

// Помимо круглых скобок существуют и другие способы сообщить JS, что мы имеем ввиду
// Function Expression:

// Способы создания IIFE
() => {
  (function () {
    console.log("Круглые скобки вокруг функции");
  })()(
    (function () {
      console.log("Круглые скобки вокруг всего выражения");
    })()
  );

  !(function () {
    console.log("Выражения начинается с логического оператора НЕ");
  })() +
    (function () {
      console.log("Выражения начинается с унарного плюса");
    })();
};

// Во всех перечисленных случаях мы объявляем Function Expression и немедленно запускаем его

///
/// Итого
///
// Существует 2 основных отличия var от let / const:
// 1. Переменные var не имеют блочной области видимости, они ограничены, как минимум телом
//    функции.
// 2. Объявление (инициализация) переменных var производится в начале исполнения функции
//    (или скрипта для глобальных переменных).
