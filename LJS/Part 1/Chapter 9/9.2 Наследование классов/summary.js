// Наследование классов
//
//
// Наследование классов – это способ расширения одного класса другим классом.

// Таким образом, мы можем добавить новый функционал к уже существующему.

// Ключевое слово «extends»
// Допустим, у нас есть класс Animal:

() => {
  class Animal {
    constructor(name) {
      this.speed = 0;
      this.name = name;
    }

    run(speed) {
      this.speed = speed;
      console.log(`${this.name} бежит со скоростью ${this.speed}`);
    }

    stop() {
      this.speed = 0;
      console.log(`${this.name} стоит неподвижно.`);
    }
  }

  let animal = new Animal("Мой питомец");

  // …И мы хотели бы создать ещё один class Rabbit.

  // Поскольку кролики – это животные, класс Rabbit должен быть основан на Animal,
  // и иметь доступ к методам животных, так чтобы кролики могли делать то,
  // что могут делать «общие» животные.

  // Синтаксис для расширения другого класса следующий: class Child extends Parent.

  // Давайте создадим class Rabbit, который наследуется от Animal:

  class Rabbit extends Animal {
    hide() {
      console.log(`${this.name} прячется!`);
    }
  }

  let rabbit = new Rabbit("Белый кролик");

  rabbit.run(5); // Белый кролик бежит со скоростью 5.
  rabbit.hide(); // Белый кролик прячется!

  // Объект класса Rabbit имеет доступ как к методам Rabbit, таким как rabbit.hide(),
  // так и к методам Animal, таким как rabbit.run().

  // Внутри ключевое слово extends работает по старой доброй механике прототипов.
  // Оно устанавливает Rabbit.prototype.[[Prototype]] в Animal.prototype.
  // Таким образом, если метода не оказалось в Rabbit.prototype, JavaScript берет
  // его из Animal.prototype.

  //   Например, чтобы найти метод rabbit.run, движок проверяет:

  // - Объект rabbit (не имеет run).
  // - Его прототип, то есть Rabbit.prototype (имеет hide, но не имеет run).
  // - Его прототип, то есть (вследствие extends) Animal.prototype, в котором, наконец, есть метод run.

  // Как мы помним из главы Встроенные прототипы, сам JavaScript использует наследование на
  // прототипах для встроенных объектов.
  // Например, Date.prototype.[[Prototype]] является Object.prototype, поэтому у дат есть
  // универсальные методы объекта.
};

//
// Переопределение методов
//
// Теперь давайте продвинемся дальше и переопределим метод.
// По умолчанию все методы, не указанные в классе Rabbit,
// берутся непосредственно «как есть» из класса Animal.

// Но если мы укажем в Rabbit собственный метод, например stop(), то он будет использован
// вместо него:

() => {
  class Rabbit extends Animal {
    stop() {}
    // ...теперь это будет использоваться для rabbit.stop()
    // вместо stop() из класса Animal
  }

  // Впрочем, обычно мы не хотим полностью заменить родительский метод,
  // а скорее хотим сделать новый на его основе, изменяя или расширяя его функциональность.
  // Мы делаем что-то в нашем методе и вызываем родительский метод до/после или в процессе.

  // У классов есть ключевое слово "super" для таких случаев.

  // - super.method(...) вызывает родительский метод.
  // - super(...) для вызова родительского конструктора (работает только внутри нашего конструктора).

  // Пусть наш кролик автоматически прячется при остановке:

  () => {
    class Animal {
      constructor(name) {
        this.speed = 0;
        this.name = name;
      }

      run(speed) {
        this.speed = speed;
        console.log(`${this.name} бежит со скоростью ${this.speed}`);
      }

      stop() {
        this.speed = 0;
        console.log(`${this.name} стоит.`);
      }
    }

    class Rabbit extends Animal {
      hide() {
        console.log(`${this.name} прячется!`);
      }

      stop() {
        super.stop(); // Вызываем родительский метод stop
        this.hide(); // И затем hide
      }
    }

    let rabbit = new Rabbit("Белый кролик");

    rabbit.run(5); // Белый кролик бежит со скоростью 5
    rabbit.stop(); // Белый кролик стоит. Белый кролик прячется!
  };

  //   Теперь у класса Rabbit есть метод stop, который вызывает родительский super.stop()
  //   в процессе выполнения.
};

// У стрелочных функций нет super
// Как упоминалось в главе Повторяем стрелочные функции, стрелочные функции не имеют super.

// При обращении к super стрелочной функции он берётся из внешней функции:

() => {
  class Rabbit extends Animal {
    stop() {
      setTimeout(() => super.stop(), 1000); // вызывает родительский stop после 1 секунды
    }
  }

  // В примере super в стрелочной функции тот же самый, что и в stop(),
  // поэтому метод отрабатывает как и ожидается.
  // Если бы мы указали здесь «обычную» функцию, была бы ошибка:

  () => {
    // Unexpected super
    setTimeout(function () {
      super.stop();
    }, 1000);
  };
};

//
// Переопределение конструктора
// С конструкторами немного сложнее.

// До сих пор у Rabbit не было своего конструктора.

// Согласно спецификации, если класс расширяет другой класс и не имеет конструктора,
// то автоматически создаётся такой «пустой» конструктор:

() => {
  class Rabbit extends Animal {
    // генерируется для классов-потомков, у которых нет своего конструктора
    constructor(...args) {
      super(...args);
    }
  }
};

// Как мы видим, он просто вызывает конструктор родительского класса.
// Так будет происходить, пока мы не создадим собственный конструктор.

// Давайте добавим конструктор для Rabbit. Он будет устанавливать earLength в дополнение к name:

() => {
  class Animal {
    constructor(name) {
      this.name = name;
      this.speed = 0;
    }
  }

  class Rabbit extends Animal {
    constructor(name, earLength) {
      this.speed = 0;
      this.name = name;
      this.earLength = earLength;
    }
  }

  // Не работает!
  //   ReferenceError:
  //   Must call super constructor in derived class before accessing 'this'
  //   or returning from derived constructor
  let rabbit = new Rabbit("Белый кролик", 10); // Error: this is not defined.

  // Упс! При создании кролика – ошибка! Что не так?

  // Если коротко, то:

  // Конструкторы в наследуемых классах должны обязательно вызывать super(...),
  // и (!) делать это перед использованием this.

  // …Но почему? Что происходит? Это требование кажется довольно странным.

  // Конечно, всему есть своё объяснение.
  // Давайте углубимся в детали, чтобы вы действительно поняли, что происходит.

  // В JavaScript существует различие между «функцией-конструктором наследующего класса» и
  // всеми остальными. В наследующем классе соответствующая функция-конструктор помечена
  // специальным внутренним свойством [[ConstructorKind]]:"derived".

  // Разница в следующем:
  // - Когда выполняется обычный конструктор, он создаёт пустой объект и присваивает его this.

  // - Когда запускается конструктор унаследованного класса, он этого не делает.
  //   Вместо этого он ждёт, что это сделает конструктор родительского класса.

  // Поэтому, если мы создаём собственный конструктор, мы должны вызвать super,
  // в противном случае объект для this не будет создан, и мы получим ошибку.

  // Чтобы конструктор Rabbit работал, он должен вызвать super() до того,
  // как использовать this, чтобы не было ошибки:

  () => {
    class Animal {
      constructor(name) {
        this.name = name;
        this.speed = 0;
      }
    }

    class Rabbit extends Animal {
      constructor(name, earLength) {
        super(name);
        this.earLength = earLength;
      }
    }

    // теперь работает
    let rabbit = new Rabbit("Белый кролик", 10);
    console.log(rabbit.name); // Белый кролик
    console.log(rabbit.earLength); // 10
  };
};

//
// Переопределение полей класса: тонкое замечание
//
// Мы можем переопределять не только метроды, но и поля класса.
//
// Однако, когда мы получаем доступ к переопределенному полю в родительском конструкторе, это
// поведение отличается от большинства других ЯП.

// Рассмотрим этот пример:

() => {
  class Animal {
    name = "animal";

    constructor() {
      console.log(this.name);
    }
  }

  class Rabbit extends Animal {
    name = "rabbit";
  }

  new Animal(); // animal
  new Rabbit(); // animal

  // Здесь, класс Rabbit расширяет Animal и переопределяет поле name своим собственным значением.
  // В Rabbit нет собственного конструктора, поэтому вызывается конструктор Animal.
  //
  // Что интересно, в обоих случаях: new Animal() и new Rabbit(), console.log() показывает animal.
  //
  // Другими словами, родительский конструктор всегда использует своё собственное значение поля,
  // а не переопределённое.

  // Что же в этом странного?

  // Если это ещё не ясно, сравните с методами.

  // Вот тот же код, но вместо поля this.name, мы вызываем метод this.showName():

  () => {
    class Animal {
      showName() {
        // вместо this.name = 'animal'
        console.log("animal");
      }
      constructor() {
        this.showName(); // вместо console.log(this.name);
      }
    }

    class Rabbit extends Animal {
      showName() {
        console.log("rabbit");
      }
    }

    new Animal(); // animal
    new Rabbit(); // rabbit

    // Обратите внимание: теперь результат другой.

    // И это то, чего мы, естественно, ожидаем. Когда родительский конструктор вызывается в
    // производном классе, он использует переопределённый метод.

    // …Но для полей класса это не так. Как уже было сказано, родительский конструктор всегда
    // использует родительское поле.

    // Почему же наблюдается разница?

    // Что ж, причина заключается в порядке инициализации полей. Поле класса инициализируется:
    //  -  Перед конструктором для базового класса (который ничего не расширяет),
    //  -  Сразу после super() для производного класса.

    // Если это становится проблемой, её можно решить, используя методы или
    // геттеры/сеттеры вместо полей.
  };
};

//
//
// Устройство super, [[HomeObject]]
//
//
// Давайте заглянем «под капот» super. Здесь есть некоторые интересные моменты.

// Вообще, исходя из наших знаний до этого момента, super вообще не может работать!

// Ну правда, давайте спросим себя – как он должен работать, чисто технически?
// Когда метод объекта выполняется, он получает текущий объект как this.
// Если мы вызываем super.method(), то движку необходимо получить method из прототипа текущего объекта.
// И как ему это сделать?
//
// Задача может показаться простой, но это не так. Движок знает текущий this и мог бы попытаться
// получить родительский метод как this.__proto__.method. Однако, увы, такой «наивный» путь не работает.
//
// Продемонстрируем проблему. Без классов, используя простые объекты для наглядности.
//
// В примере ниже rabbit.__proto__ = animal.
// Попробуем в rabbit.eat() вызвать animal.eat(), используя this.__proto__:

() => {
  let animal = {
    name: "Animal",
    eat() {
      console.log(`${this.name} ест.`);
    },
  };

  let rabbit = {
    __proto__: animal,
    name: "Кролик",
    eat() {
      // вот как предположительно может работать super.eat()
      this.__proto__.eat.call(this); // (*)
    },
  };

  rabbit.eat(); // Кролик ест.
};

//
// [[HomeObject]]
//

// Когда функция объявлена как метод внутри класса или объекта,
// её свойство [[HomeObject]] становится равно этому объекту.

// Затем super использует его, чтобы получить прототип родителя и его методы.

// Давайте посмотрим, как это работает – опять же, используя простые объекты:

() => {
  let animal = {
    name: "Животное",
    eat() {
      // animal.eat.[[HomeObject]] == animal
      console.log(`${this.name} ест.`);
    },
  };

  let rabbit = {
    __proto__: animal,
    name: "Кролик",
    eat() {
      // rabbit.eat.[[HomeObject]] == rabbit
      super.eat();
    },
  };

  let longEar = {
    __proto__: rabbit,
    name: "Длинноух",
    eat() {
      // longEar.eat.[[HomeObject]] == longEar
      super.eat();
    },
  };

  // работает верно
  longEar.eat(); // Длинноух ест.
};

//
// Итого
//
// 1. Чтобы унаследовать от класса: class Child extends Parent:
//  - При этом Child.prototype.__proto__ будет равен Parent.prototype, так что методы будут унаследованы.

// 2. При переопределении конструктора:
// - Обязателен вызов конструктора родителя super() в конструкторе Child до обращения к this.

// 3. При переопределении другого метода:
// - Мы можем вызвать super.method() в методе Child для обращения к методу родителя Parent.

// 4. Внутренние детали:
// - Методы запоминают свой объект во внутреннем свойстве [[HomeObject]]. Благодаря этому работает super,
//   он в его прототипе ищет родительские методы.
// - Поэтому копировать метод, использующий super, между разными объектами небезопасно.

// Также:

// - У стрелочных функций нет своего this и super, поэтому они «прозрачно» встраиваются во внешний контекст.
