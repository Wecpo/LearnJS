// Остаточные параметры и оператор расширения
//
// Многие встроенные функции JS поддерживают произвольное кол-во аргументов.
// Например:
// - Math.max(arg1, arg2, ..., argN) - Вычисляет максимальное кол-во из переданных
// - Object.assign(dest, src1, ..., srcN) - Копирует свойства из исходных объектов src1..N в
//   целевой объект dest.
//
// Остаточные параметры (...)
//
// Вызвать функцию можно с любым кол-вом аргументов, независимо от того, как она была
// определена.
// Например:
() => {
  function sum(a, b) {
    return a + b;
  }

  console.log(sum(1, 2, 3, 4, 5));

  // Лишние аргументы не вызовуз ошибку, но не будут учтены.
  // Остаточные параметры могут быть обозначены через три точки ...
  // Буквально это значит: собери оставшиеся параметры и положи их в массив.
  // Например, соберем все аргументы в массив args:
  function sumAll(...args) {
    let sum = 0;
    for (let arg of args) {
      sum += arg;
    }
    return sum;
  }

  console.log(1);
  console.log(1, 2);
  console.log(1, 2, 3);
};

// Мы можем положить первые несколько параметров в переменные, а остальные собрать в массив.
// В примере ниже первые два аргумента функции станут именем и фамилией, а третий и
// последующие превратятся в массив titles.
() => {
  function showName(firstName, lastName, ...titles) {
    console.log(firstName + " " + lastName);
    console.log(titles[0]); // Консул
    console.log(titles[1]); // Император
    console.log(titles.length); // 2
  }
  showName("Юлий", "Цезарь", "Консул", "Император");

  // Остаточные параметры должны распологаться в конце.
  // Остаточные параметры собираются все остальные аргуметны, поэтому бессмысленно
  // писать что-либо после них. Это вызовет ошибку
  // ...rest должен всегда быть последним
};

// Переменная 'arguments'
//
// Все аргументы функции находятся в псевдомассиве arguments под своими порядковыми номерами.
// Например:
() => {
  function showName() {
    console.log(arguments.length);
    console.log(arguments[0]);
    console.log(arguments[1]);
  }
  showName("Юлий", "Цезарь"); // 2, Юлий, Цезарь
  showName("Илья"); // 1, Илья, undefined
  // Раньше в языке не было остаточных параметров, и получить все аргументы функции можно
  // было только с помощью arguments. Этот способ все еще работает, мы можем найти его
  // в старом коде.
  //
  // Но у него есть один недостаток. Хотя arguments похож на массив, и его тоже можно
  // перебирать, это все же не массив. Он не поддерживает методы массивов, поэтому мы
  // не можем, например вызвать arguments.map(...)
  //
  // Соответственно, для более удобной работы с аргументами, лучше использовать
  // Остаточные параметры.
  //
  // Стрелочные функции не имеют arguments
  // Если мы обратимся к arguments из стрелочной функции, то получим аргументы внешей,
  // "нормальной" функции.
  //
  // Пример:
  //
  function f() {
    let showArg = () => console.log(arguments[0]);
    showArg(2);
  }
  f(1); // 1

  // Как мы помним, у стрелочных функций нет собственного this. Теперь мы знаем, что нет и
  // своего объекта arguments.
};

// Оператор расширения
// Работает только с итерируемыми объектами
// Array.from работает как с псевдомассивами, так и с итерируемыми объектами

// Итого
//
// Когда мы видим '...' в коде, это могут быть как остаточные параметры, так и оператор spread
// Как отличить их друг от друга:
// - Если ... располагается в конце списка параметров функции, то это остаточные параметры.
//   Он собирает остальные неуказанные агрументы в массив.
// - Если ... встретился в вызове функции или где-либо еще, то это spread. Он извлекает
//   элементы из массива.
//
// Полезно запомнить:
// - Остаточные параметры используются, чтобы создавать новые функции с неопределенным числом
//   аргументов
// - С помощью оператора расширения можно вставить массив в функцию, которая по умолчанию
//   работает в обычным списком аргументов.
//
// Вместе эти конструкции помогают легко преобразовывать наборы значений в массивы и обратно
// К аргументам функции можно обращаться и по старому - через псевдомассив (args.)
