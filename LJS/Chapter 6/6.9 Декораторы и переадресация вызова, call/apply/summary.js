// Декораторы и переадресация вызова, call/apply

// JavaScript предоставляет исключительно гибкие возможности по работе с функциями:
//  они могут быть переданы в другие функции, использованы как объекты,
//   и сейчас мы рассмотрим, как перенаправлять вызовы между ними и как их декорировать.
//
// Прозрачное кеширование
//
// Представим, что у нас есть функция slow(x), выполняющая ресурсоемкие вычисления, но
// возвращающая стабильные результаты. Другими словами, для одного и того же 'x' она
// всегда возвращает один и тот же результат.
//
// Если функция вызывается часто, то, вероятно мы захотим кешировать (запоминать)
// возвращаемые ею результаты, чтобы экономить на повторных вычислениях.
//
// Вместо того, чтобы усложнять slow(x) дополнительной функциональностью, мы заключим
// ее в функцию обертку - 'wrapper', которая добавит кеширование. Далее мы увидим,
// что в таком подхое масса преимуществ.
//
// Вот код с объяснением:
() => {
  function slow(x) {
    // Здесь могут быть ресурсоемкие вычисления
    console.log(`Called with ${x}`);
    return x;
  }

  function cachingDecorator(func) {
    let cache = new Map();

    return function (x) {
      if (cache.has(x)) {
        // если кеш содержит такой 'x'
        console.log(`res from cache`);
        return cache.get(x); // читаем из него результат
      }
      let result = func(x); // иначе, вызываем функцию

      cache.set(x, result); // и кешируем результат
      return result;
    };
  }

  slow = cachingDecorator(slow);

  console.log(slow(1)); // slow(1) кешируем
  console.log(`Again: ` + slow(1)); // возвращаем из кеша

  console.log(slow(2)); // slow(1) кешируем
  console.log(`Again: ` + slow(2)); // возвращаем из кеша
};

// В коде выше cachingDecorator – это декоратор, специальная функция,
// которая принимает другую функцию и изменяет её поведение.
//
// Идея состоит в том, что мы можем вызвать cachingDecorator с любой функцией,
// в результате чего мы получим кеширующую обёртку.
// Это здорово, т.к. у нас может быть множество функций,
// использующих такую функциональность, и всё,
// что нам нужно сделать – это применить к ним cachingDecorator.
//
// Отделяя кеширующий код от основного кода,
// мы также сохраняем чистоту и простоту последнего.
//
// С точки зрения внешнего кода, обёрнутая функция slow по-прежнему делает то же самое.
// Обёртка всего лишь добавляет к её поведению аспект кеширования.

// Подводя итог, можно выделить несколько преимуществ использования
//  отдельной cachingDecorator вместо изменения кода самой slow:
// - Функцию cachingDecorator можно использовать повторно. Мы можем применить
//   её к другой функции.

// - Логика кеширования является отдельной, она не увеличивает сложность самой
//   slow (если таковая была).

// - При необходимости мы можем объединить несколько декораторов
//   (речь об этом пойдёт позже).
