// Сумма с помощью замыканий
// важность: 4
// Напишите функцию sum, которая работает таким образом: sum(a)(b) = a+b.

// Да, именно таким образом, используя двойные круглые скобки (не опечатка).

// Например:

// sum(1)(2) = 3
// sum(5)(-1) = 4

() => {
  function sum(a) {
    return function (b) {
      return a + b;
    };
  }
  sum(1)(2);
};

() => {
  //   Учитывает ли функция последние изменения?

  // Функция sayHi использует имя внешней переменной. Какое значение будет использоваться прини
  // Выполнении функции?

  let name = "John";

  function sayHi() {
    alert("Hi, " + name);
  }

  name = "Pete";

  sayHi(); // что будет показано: "John" или "Pete"?
  // Ответ Pete
  // На момент вызова функции name = 'Pete'
};

() => {
  // Какие переменные доступны?

  // Приведенная ниже функция makeWorker создает другую функцию и возвращает ее. Эта новая
  // Функция может быть вызвана из другого места.

  // Будет ли она иметь доступ к внешним переменным из места своего создания, или из места
  // Вызова, или из обоих мест?

  function makeWorker() {
    let name = "Pete";

    return function () {
      alert(name);
    };
  }

  let name = "John";

  // создаём функцию
  let work = makeWorker();

  // вызываем её
  work(); // что будет показано?
  // Какое значение будет показано? «Pete» или «John»?
  // 'Pete', потому-что в самой функции есть переменная name и она равна 'Pete'
  // При выполнении функция не пойдет во внешнюю область видимости
};

() => {
  // Независимы ли счетчики?

  // Здесь мы делаем два счетчика: counter и counter2, используя одну и ту же функцию
  // makeCounter. Они независимы? Что покажет второй счетчик? 0, 1 или 2, 3 или что-то еще?

  function makeCounter() {
    let count = 0;

    return function () {
      return count++;
    };
  }

  let counter = makeCounter();
  let counter2 = makeCounter();

  alert(counter()); // 0
  alert(counter()); // 1

  alert(counter2()); // 0
  alert(counter2()); // 1

  // Ответ 0, 1. Функции созданы отдельно друг от друга и имеют собственные лексические
  // окружения. У каждого свой count.
};

() => {
  //   Объект счётчика
  // Здесь объект счётчика создан с помощью функции-конструктора.

  // Будет ли он работать? Что покажет?

  function Counter() {
    let count = 0;

    this.up = function () {
      return ++count;
    };
    this.down = function () {
      return --count;
    };
  }

  let counter = new Counter();

  alert(counter.up()); // ? 1
  alert(counter.up()); // ? 2
  alert(counter.down()); // ? 1

  let counter2 = new Counter();
  console.log(counter2.up());
  console.log(counter2.up());
  console.log(counter2.down());
  // Будет работать
};

() => {
  //   Функция внутри if
  // Посмотрите на код. Какой будет результат у вызова на последней строке?

  // Обратите внимание: результат зависит от режима выполнения кода.
  // Здесь используется строгий режим "use strict".

  let phrase = "Hello";

  if (true) {
    let user = "John";

    function sayHi() {
      alert(`${phrase}, ${user}`);
    }
  }

  sayHi(); // Ошибка // sayHi есть только внутри if
};

() => {
  //   Видна ли переменная?
  // важность: 4
  // Что выведет данный код?

  let x = 1;

  function func() {
    console.log(x); // ?

    let x = 2;
  }

  func();
  // Ошибка - обращение к переменной до ее инициализации.
};

() => {
  // Фильтрация с помощью функции
  // У нас есть встроенный метод arr.filter(f) для массивов.
  // Он фильтрует все элементы с помощью функции f.
  // Если она возвращает true, то элемент добавится в возвращаемый массив.

  // Сделайте набор «готовых к употреблению» фильтров:

  // inBetween(a, b) – между a и b (включительно).
  // inArray([...]) – находится в данном массиве.
  // Они должны использоваться таким образом:

  // arr.filter(inBetween(3,6)) – выбирает только значения между 3 и 6 (включительно).
  // arr.filter(inArray([1,2,3])) – выбирает только элементы,
  //  совпадающие с одним из элементов массива
  // Например:

  /* .. ваш код для inBetween и inArray */
  let arr = [1, 2, 3, 4, 5, 6, 7];

  function inBetween(a, b) {
    return function (x) {
      console.log(arguments);
      if (x >= a && x <= b) {
        return x;
      }
    };
  }

  function inArray(arr) {
    return function (x) {
      if (arr.includes(x)) {
        return x;
      }
      // return arr.includes(x)
    };
  }

  alert(arr.filter(inBetween(3, 6))); // 3,4,5,6

  alert(arr.filter(inArray([1, 2, 10]))); // 1,2
};

() => {
  //   Сортировать по полю
  // важность: 5
  // У нас есть массив объектов, который нужно отсортировать:

  let users = [
    { name: "Иван", age: 20, surname: "Иванов" },
    { name: "Пётр", age: 18, surname: "Петров" },
    { name: "Анна", age: 19, surname: "Каренина" },
  ];
  // Обычный способ был бы таким:

  // по имени (Анна, Иван, Пётр)
  // users.sort((a, b) => (a.name > b.name ? 1 : -1));

  // по возрасту (Пётр, Анна, Иван)
  // users.sort((a, b) => (a.age > b.age ? 1 : -1));
  // Можем ли мы сделать его короче, например вот таким?

  users.sort(byField("name"));
  users.sort(byField("age"));
  // То есть чтобы вместо функции мы просто писали byField(fieldName).

  function byField(key) {
    return function (a, b) {
      if (a[key] > b[key]) {
        return 1;
      } else return -1;
    };
  }
};

() => {
  //   Армия функций
  // Следующий код создаёт массив из стрелков (shooters).

  // Каждая функция предназначена выводить их порядковые номера. Но что-то пошло не так…

  function makeArmy() {
    let shooters = [];

    for (let i = 0; i < 10; i++) {
      let shooter = function () {
        // функция shooter
        alert(i); // должна выводить порядковый номер
      };
      shooters.push(shooter); // и добавлять стрелка в массив
    }

    // ...а в конце вернуть массив из всех стрелков
    return shooters;
  }

  let army = makeArmy();

  // все стрелки выводят 10 вместо их порядковых номеров (0, 1, 2, 3...)
  army[0](); // 10 от стрелка с порядковым номером 0
  army[1](); // 10 от стрелка с порядковым номером 1
  army[2](); // 10 ...и т.д.
  // Почему у всех стрелков одинаковые номера?

  // Почините код, чтобы он работал как задумано.
};
